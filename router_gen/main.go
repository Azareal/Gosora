/* WIP Under Construction */
package main

import (
	"log"
	"os"
)

//import "strings"

var routeList []*RouteImpl
var routeGroups []*RouteGroup

func main() {
	log.Println("Generating the router...")

	// Load all the routes...
	routes()

	var out, routeMap string
	var mapIt = func(name string) {
		routeMap += "\t\"" + name + "\": " + name + ",\n"
		//reverseRouteMap += "\t" + name + ": \"" + name + "\",\n"
	}
	var countToIndents = func(indent int) (indentor string) {
		for i := 0; i < indent; i++ {
			indentor += "\t"
		}
		return indentor
	}
	var runBefore = func(runnables []Runnable, indent int) (out string) {
		var indentor = countToIndents(indent)
		if len(runnables) > 0 {
			for _, runnable := range runnables {
				if runnable.Literal {
					out += "\n\t" + indentor + runnable.Contents
				} else {
					out += "\n" + indentor + "err = common." + runnable.Contents + "(w,req,user)\n" +
						indentor + "if err != nil {\n" +
						indentor + "\trouter.handleError(err,w,req,user)\n" +
						indentor + "\treturn\n" +
						indentor + "}\n" + indentor
				}
			}
		}
		return out
	}

	for _, route := range routeList {
		var end = len(route.Path) - 1
		out += "\n\t\tcase \"" + route.Path[0:end] + "\":"
		out += runBefore(route.RunBefore, 4)
		out += "\n\t\t\terr = " + route.Name + "(w,req,user"
		for _, item := range route.Vars {
			out += "," + item
		}
		out += `)
			if err != nil {
				router.handleError(err,w,req,user)
			}`
		mapIt(route.Name)
	}

	for _, group := range routeGroups {
		var end = len(group.Path) - 1
		out += "\n\t\tcase \"" + group.Path[0:end] + "\":"
		out += runBefore(group.RunBefore, 3)
		out += "\n\t\t\tswitch(req.URL.Path) {"

		var defaultRoute = blankRoute()
		for _, route := range group.RouteList {
			if group.Path == route.Path {
				defaultRoute = route
				continue
			}

			out += "\n\t\t\t\tcase \"" + route.Path + "\":"
			if len(route.RunBefore) > 0 {
			skipRunnable:
				for _, runnable := range route.RunBefore {
					for _, gRunnable := range group.RunBefore {
						if gRunnable.Contents == runnable.Contents {
							continue
						}
						// TODO: Stop hard-coding these
						if gRunnable.Contents == "AdminOnly" && runnable.Contents == "MemberOnly" {
							continue skipRunnable
						}
						if gRunnable.Contents == "AdminOnly" && runnable.Contents == "SuperModOnly" {
							continue skipRunnable
						}
						if gRunnable.Contents == "SuperModOnly" && runnable.Contents == "MemberOnly" {
							continue skipRunnable
						}
					}

					if runnable.Literal {
						out += "\n\t\t\t\t\t" + runnable.Contents
					} else {
						out += `
					err = common.` + runnable.Contents + `(w,req,user)
					if err != nil {
						router.handleError(err,w,req,user)
						return
					}
					`
					}
				}
			}
			out += "\n\t\t\t\t\terr = " + route.Name + "(w,req,user"
			for _, item := range route.Vars {
				out += "," + item
			}
			out += ")"
			mapIt(route.Name)
		}

		if defaultRoute.Name != "" {
			out += "\n\t\t\t\tdefault:"
			out += runBefore(defaultRoute.RunBefore, 4)
			out += "\n\t\t\t\t\terr = " + defaultRoute.Name + "(w,req,user"
			for _, item := range defaultRoute.Vars {
				out += ", " + item
			}
			out += ")"
			mapIt(defaultRoute.Name)
		}
		out += `
			}
			if err != nil {
				router.handleError(err,w,req,user)
			}`
	}

	var fileData = `// Code generated by. DO NOT EDIT.
/* This file was automatically generated by the software. Please don't edit it as your changes may be overwritten at any moment. */
package main

import (
	"log"
	"strings"
	"sync"
	"errors"
	"net/http"

	"./common"
)

var ErrNoRoute = errors.New("That route doesn't exist.")
var RouteMap = map[string]interface{}{
` + routeMap + `}

type GenRouter struct {
	UploadHandler func(http.ResponseWriter, *http.Request)
	extra_routes map[string]func(http.ResponseWriter, *http.Request, common.User) common.RouteError
	
	sync.RWMutex
}

func NewGenRouter(uploads http.Handler) *GenRouter {
	return &GenRouter{
		UploadHandler: http.StripPrefix("/uploads/",uploads).ServeHTTP,
		extra_routes: make(map[string]func(http.ResponseWriter, *http.Request, common.User) common.RouteError),
	}
}

func (router *GenRouter) handleError(err common.RouteError, w http.ResponseWriter, r *http.Request, user common.User) {
	if err.Handled() {
		return
	}
	
	if err.Type() == "system" {
		common.InternalErrorJSQ(err, w, r, err.JSON())
		return
	}
	common.LocalErrorJSQ(err.Error(), w, r, user,err.JSON())
}

func (router *GenRouter) Handle(_ string, _ http.Handler) {
}

func (router *GenRouter) HandleFunc(pattern string, handle func(http.ResponseWriter, *http.Request, common.User) common.RouteError) {
	router.Lock()
	defer router.Unlock()
	router.extra_routes[pattern] = handle
}

func (router *GenRouter) RemoveFunc(pattern string) error {
	router.Lock()
	defer router.Unlock()
	_, ok := router.extra_routes[pattern]
	if !ok {
		return ErrNoRoute
	}
	delete(router.extra_routes, pattern)
	return nil
}

func (router *GenRouter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	if len(req.URL.Path) == 0 || req.URL.Path[0] != '/' {
		w.WriteHeader(405)
		w.Write([]byte(""))
		return
	}
	
	var prefix, extra_data string
	prefix = req.URL.Path[0:strings.IndexByte(req.URL.Path[1:],'/') + 1]
	if req.URL.Path[len(req.URL.Path) - 1] != '/' {
		extra_data = req.URL.Path[strings.LastIndexByte(req.URL.Path,'/') + 1:]
		req.URL.Path = req.URL.Path[:strings.LastIndexByte(req.URL.Path,'/') + 1]
	}
	
	if common.Dev.SuperDebug {
		log.Print("before routeStatic")
		log.Print("prefix: ", prefix)
		log.Print("req.URL.Path: ", req.URL.Path)
		log.Print("extra_data: ", extra_data)
		log.Print("req.Referer(): ", req.Referer())
	}
	
	if prefix == "/static" {
		req.URL.Path += extra_data
		routeStatic(w, req)
		return
	}
	if common.Dev.SuperDebug {
		log.Print("before PreRoute")
	}

	// Increment the global view counter
	common.GlobalViewCounter.Bump()
	
	// Deal with the session stuff, etc.
	user, ok := common.PreRoute(w, req)
	if !ok {
		return
	}
	if common.Dev.SuperDebug {
		log.Print("after PreRoute")
	}
	
	var err common.RouteError
	switch(prefix) {` + out + `
		case "/uploads":
			if extra_data == "" {
				common.NotFound(w,req)
				return
			}
			req.URL.Path += extra_data
			// TODO: Find a way to propagate errors up from this?
			router.UploadHandler(w,req)
		case "":
			// Stop the favicons, robots.txt file, etc. resolving to the topics list
			// TODO: Add support for favicons and robots.txt files
			switch(extra_data) {
				case "robots.txt":
					err = routeRobotsTxt(w,req)
					if err != nil {
						router.handleError(err,w,req,user)
					}
					return
			}
			
			if extra_data != "" {
				common.NotFound(w,req)
				return
			}
			common.Config.DefaultRoute(w,req,user)
		default:
			// A fallback for the routes which haven't been converted to the new router yet or plugins
			router.RLock()
			handle, ok := router.extra_routes[req.URL.Path]
			router.RUnlock()
			
			if ok {
				req.URL.Path += extra_data
				err = handle(w,req,user)
				if err != nil {
					router.handleError(err,w,req,user)
				}
				return
			}
			common.NotFound(w,req)
	}
}
`
	writeFile("./gen_router.go", fileData)
	log.Println("Successfully generated the router")
}

func writeFile(name string, content string) {
	f, err := os.Create(name)
	if err != nil {
		log.Fatal(err)
	}
	_, err = f.WriteString(content)
	if err != nil {
		log.Fatal(err)
	}
	f.Sync()
	f.Close()
}
